#1. Использовал Jmap. jmap -histo:live,file=C:\tools\histo.data 5548 (Выгружает в указанный файл список живых объектов работающего приложения с id 5548)
По-умолчанию используется ключ all, вместо live, который показывает и живые и мертвые объекты.
Формат файла ниже. Показано количество экземпляров объекта соответствующего класса и количество памяти которые они занимают.
 num     #instances         #bytes  class name (module)
-------------------------------------------------------
   1:          9110         568240  [B (java.base@16.0.1)
   2:          8604         206496  java.lang.String (java.base@16.0.1)
   3:          1278         155904  java.lang.Class (java.base@16.0.1)
   4:          4098         131136  java.util.HashMap$Node (java.base@16.0.1)
   5:          1423         101192  [Ljava.lang.Object; (java.base@16.0.1)
   6:           227          80664  [C (java.base@16.0.1)
   7:           339          62512  [Ljava.util.HashMap$Node; (java.base@16.0.1)
   8:          1432          45824  java.util.concurrent.ConcurrentHashMap$Node (java.base@16.0.1)
   9:          1073          42920  java.util.LinkedHashMap$Entry (java.base@16.0.1)
  10:           214          27280  [I (java.base@16.0.1)

Можно сделать дамп памяти в определенным момент работы приложеия командой jmap -dump:live,format=b,file=C:\tools\dump.bin 5548

#2. Использовал jstat -gc 22680 1s 100 (ограничил память соответствующими ключами, чтобы Эдему досталось около 1 мб).
Добавлял заявки, редактировал, удалял. Увеличивалось количество сборок YGC, изменялись объемы используемых S1C, ЕU и OU.

S0C: Текущая емкость пространства для выживших(КБ).
S1C: Текущая емкость пространства для выживших(КБ).
S0U: Использование оставшегося в живых пространства(КБ).
S1U: Использование пространства для выживших(КБ).
EC: Текущая вместимость пространства eden (КБ).
ЕU: Использование пространства Эдема (КБ).
OC: Текущая емкость старого пространства (КБ).
OU: Использование старого пространства (КБ).
YGC: Количество мероприятий по сбору мусора для молодого поколения (GC).
YGCT: Время сбора мусора молодым поколением.
FGC: Количество полных событий GC.

#3. Использовал jconsole и производил те же самые действия с MemTracker. Видел изменяющиеся показатели закгруженных Классов, изменение количества потоков
и использование heap при каждой процедуре добавления/удаления объектов и при завершении работы приложения.
